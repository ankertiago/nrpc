# 单例模式 (Singleton Pattern) 实现指南

## 概述

单例模式是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点。这个模式在需要控制实例数量的场景中非常有用，比如数据库连接池、日志记录器、配置管理器等。

## 实现方式

本项目提供了5种不同的单例模式实现方式，每种都有其特点和适用场景：

### 1. 饿汉式单例 (EagerSingleton)

**特点：**
- 在类加载时就创建实例
- 线程安全
- 实现简单

**优点：**
- 天然线程安全
- 性能好，获取实例时没有同步开销
- 实现简单，代码清晰

**缺点：**
- 不管是否使用都会创建实例，可能造成资源浪费
- 如果构造函数中有异常，程序启动时就会失败

**适用场景：**
- 应用程序中一定会使用到该实例
- 实例创建成本不高
- 对启动时间要求不严格

### 2. 懒汉式单例 (LazySingleton)

**特点：**
- 延迟加载，只有在需要时才创建实例
- 使用 synchronized 保证线程安全

**优点：**
- 节省资源，避免不必要的实例创建
- 延迟加载，只有在使用时才初始化

**缺点：**
- 性能较差，每次获取实例都需要同步
- 在高并发环境下可能成为瓶颈

**适用场景：**
- 实例创建成本较高
- 实例可能不会被使用
- 并发访问不频繁的场景

### 3. 双重检查锁定单例 (DoubleCheckedLockingSingleton)

**特点：**
- 延迟加载
- 使用双重检查机制减少同步开销
- 使用 volatile 关键字保证可见性

**优点：**
- 延迟加载，节省资源
- 线程安全且性能较好
- 只在第一次创建时需要同步

**缺点：**
- 实现相对复杂
- 需要正确使用 volatile 关键字

**适用场景：**
- 高并发环境
- 需要延迟加载
- 对性能有较高要求

### 4. 枚举单例 (EnumSingleton) ⭐ **推荐**

**特点：**
- 使用枚举实现单例
- JVM 级别保证线程安全和唯一性

**优点：**
- 线程安全，JVM 保证枚举实例的唯一性
- 防止反射攻击
- 防止序列化破坏单例
- 实现简洁，代码少
- 延迟加载（在第一次使用时才会被加载）

**缺点：**
- 枚举类型在某些情况下可能不够灵活
- 不能继承其他类

**适用场景：**
- 大部分单例使用场景（推荐使用）
- 需要防止反射和序列化攻击
- 对代码简洁性有要求

### 5. 静态内部类单例 (StaticInnerClassSingleton) ⭐ **推荐**

**特点：**
- 使用静态内部类实现延迟加载
- JVM 保证类加载过程的线程安全

**优点：**
- 延迟加载，只有在调用 getInstance() 时才会加载内部类
- 线程安全，JVM 保证类加载过程的线程安全
- 性能好，没有同步开销
- 实现简洁

**缺点：**
- 相对其他方式稍复杂一些

**适用场景：**
- 需要延迟加载的高性能场景
- 不能使用枚举的情况
- 大部分企业级应用场景

## 安全性考虑

### 反射攻击防护

所有实现都包含了反射攻击防护，在构造函数中检查实例是否已经存在：

```java
private Constructor() {
    if (instance != null) {
        throw new RuntimeException("不能通过反射创建单例实例");
    }
}
```

### 序列化攻击防护

除了枚举单例外，其他实现都提供了 `readResolve()` 方法来防止序列化破坏单例：

```java
private Object readResolve() {
    return INSTANCE;
}
```

## 性能对比

| 实现方式 | 线程安全 | 延迟加载 | 性能 | 复杂度 | 推荐度 |
|---------|---------|---------|------|-------|-------|
| 饿汉式 | ✅ | ❌ | 高 | 低 | ⭐⭐⭐ |
| 懒汉式 | ✅ | ✅ | 低 | 低 | ⭐⭐ |
| 双重检查锁定 | ✅ | ✅ | 高 | 中 | ⭐⭐⭐⭐ |
| 枚举 | ✅ | ✅ | 高 | 低 | ⭐⭐⭐⭐⭐ |
| 静态内部类 | ✅ | ✅ | 高 | 中 | ⭐⭐⭐⭐⭐ |

## 使用建议

1. **首选枚举单例**：简单、安全、高效
2. **次选静态内部类单例**：性能好、支持延迟加载
3. **特殊场景选择双重检查锁定**：需要自定义初始化逻辑时
4. **避免懒汉式**：性能较差，除非有特殊需求
5. **简单场景可选饿汉式**：如果不需要延迟加载且实例轻量

## 运行示例

编译并运行演示程序：

```bash
# 编译
javac -cp . src/main/java/com/nrpc/patterns/singleton/*.java

# 运行演示
java -cp src/main/java com.nrpc.patterns.singleton.SingletonDemo
```

## 测试

运行测试用例验证单例模式的正确性：

```bash
# 需要 JUnit 5 依赖
java -cp .:junit-platform-console-standalone.jar org.junit.platform.console.ConsoleLauncher --classpath src/test/java --scan-classpath
```

## 总结

单例模式是一个看似简单但实际上有很多细节需要注意的设计模式。正确的实现需要考虑线程安全、性能、延迟加载、反射攻击防护等多个方面。在实际项目中，推荐使用枚举单例或静态内部类单例，它们提供了最佳的安全性和性能平衡。